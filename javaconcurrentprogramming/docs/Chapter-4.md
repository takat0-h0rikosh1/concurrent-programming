# 4章

下限値が上限値以下であるという制約について。
- 複数変数からなる不変項（多変数不変項）
- 操作のアトミック性を要求する
- 一度のロックで双方の値を変更する必要がある
- ロックの手放しと再取得の間に他のスレッドにより更新によって無効なステートになるなるかもしれないから。

Counter のステート遷移
- 現在が17だったら、唯一有効な次のステートは18。

カプセル化とはクラス内のフィールド変数に private 等の修飾子を付与し、外部のクラスから影響を受けないようにするテクニック。

キューからアイテムを一つ削除できたのはキューが空ではなかったというステートに依存している。<br>
このように事前条件のある操作をステート依存と呼ぶ。

- シングルスレッドでは事前条件が成り立たなければエラーになるだけ。
- 並行プログラムでは、後から他のスレッドのアクションによって事前条件が成立するかもしれない。
- 事前条件が成立するのを待ってから操作を続ける。

条件が成り立つまで待つために
- 効率的な仕組みは wait, notify です。→ 難しい。
- BlockingQueue, Semaphore などのシンクロナイザを使うほうが楽。

### ステートのオーナー

- オブジェクトがカプセル化しているステートを所有します。
- ステート変数のステート変数の正しさを維持するためのロックのプロトコルを決定するのは、その変数のオーナーです。

## 4-2 インスタンス拘束

- カプセル化はインスタンス拘束を促進する。

**データをオブジェクト中に拘束し、データが常に正しいロックが取得された状態でアクセスされるようになる。**

拘束オブジェクトは、、、
- 本来のスコープを逸出しないために
   - たとえば private なメンバとして
   - たとえばローカル変数として
   - スレッド内でメソッドからメソッドに渡される
   - 複数スレッドに共有されない

- インスタンス拘束はスレッドセーフなクラスを作るための一番容易な方法の一つ。
  - ロック方式を選べる柔軟性もある。
  - 各ステート変数を別々のロックでガードすることもできる。
  
 ArrayList, HashMapなどの基本的なクラスコレクションはスレッドセーフではない。  
 スレッドセーフなクラスでそれらをラップするファクトリメソッド Collections.synchronizedList とその仲間達を提供してる。  
 デコレータパターンを使ってコレクションを同期化されたラッパーオブジェクトでラップする 

拘束を使うと、スレッドセーフなクラスの構築が用意です。ステートしているクラスはプログラム全体を調べなくてもそのスレッドセーフ性を分析できるからです。

### 4-2-1 Java のモニタパターン

インスタンス拘束の論理的な結論として Java のモニタパターンにたどり着く。

### 4-2-2 例: 業務車両の追跡管理

- 更新スレッドと参照のスレッドが同時にアクセスする
- 管理クラスはスレッドセーフ
- MutableTableはスレッドセーフではない
- スレッドセーフ維持のために可変データをコピーしてクライアントに返却
   - 車両が多いと性能面で問題になる
   - 位置データに内部的な整合性が要求されるなら正しいスナップショットを返すこと重要
   - 逆にスナップショットの頻繁なリフレッシュが必要なら単純にコピーして返すだけではだめ

# other

**@GuardBy について**
指定したロックを保持している場合に限り、この型の値にアクセスできることを示す。
