# Fiber について

## 登場する言葉とその意味

### プリエンプション

和訳の意味は「先取り」。

マルチタスクのコンピュータシステムが実行中のタスクを一時的に中断する動作。
基本的にそのタスクの協力は不要で、後でそのタスクを再実行するという意味も含む。このような動作をコンテキストスイッチと呼ぶ。
通常、保護されたタスクか、システムの一部であるプリエンプティブスケジューラが行う。それらは、システム内の他のタスクに割り込み、
あとでそれらタスクを再開させることができる。

### プリエンプティブなマルチタスク

ハードウェアタイマを利用して複数のプログラムの制御を切り替えていくマルチタスク方式。
ノンプリエンプティブなマルチタスクではアプリケーションの自主的な制御の開放に頼っていたのに対し、
プリエンプティブなマルチタスクでは、OSが強制的に複数のアプリケーション間で制御を切り替えることができる。
逆に言えばアプリケーションは、他のアプリケーションを「動かす」ことを意識する必要がない。
プリエンプティブなマルチタスクの長所は、マルチタスクの制御をOSが完全に掌握していることである。
この場合、アプリケーションにまったく影響を受けること無く処理が行える。制御の切り替えはハードウェアタイマベースに起こるので、
滑らかなマルチタスクキングが実現できる。

一方の短所は、ノンプリエンプティブなマルチタスクに比較するとマルチタスクを実現するために必要な処理が複雑なことである
しかし、CPUの性能向上などにより、このオーバーヘッドはパーソナル・コンピューターレベルでもそれほど問題ではなくなってきている。
プリエンプティブなマルチタスクは、伝統的なマルチタスク手法でほとんどの 32bit OS で採用されている。

停止したプログラムは状態を保存して待機し、再び順番が巡ってくると実行を再開する。このような切り替えを短い周期で繰り返すことにより、
あたかも同時に複数のプログラムが実行されているように装うことができる。

プログラム側が自主的に制御をOSに明け渡すことで実行プログラムの切り替えを行っていく方式を「ノンプリエンプティブマルチタスク」あるいは、
「協調的マルチタスク」「疑似マルチタスク」などという。初期のパソコン向けOSなどではこの方式もみられたが現在ではプリエンプティブマルチタスクが主流となっている。

### ノンプリエンプティブなマルチタスク

一つの処理装置(CPU)で並行して複数の処理を進めるマルチタスクで、OSがCPUを管理しない方式。

実行中のプログラムが短時間ごとに自発的にOSに制御を返しCPUの実行状態を並行して稼働している他のプログラムへ切り替える方式。
CPUの実行状態をOSが管理しないため、OSの構造はシンプルで済み、タスク切換え時の処理の負荷も小さい。

しかし、OSへ制御を渡す頻度やタイミングは各プログラム任せとなるため、なかなかCPUを明け渡さない「行儀の悪い」プログラムがいると、
OSや他のプログラムの処理が滞ってしまう。また、プログラムに不具合が発生し、特定の箇所で無限ループするなどして正しく切り替え処理を行わなくなってしまうと、
OSごとシステム全体が停止してしますという弱点がある。

### Fiber による協調的な並行プログラミング

#### Fiber とは

Thread に似ているが、Thread にはない特徴を備えています。

Ruby リファレンスマニュアルから Fiber クラスの説明を引用してみましょう。

```
ノンプリエンプティブな軽量スレッド（以下ファイバーと呼ぶ）を提供します。他の言語では coroutine あるいは semicoroutine と
呼ばれる場合もあります。Thread と違いユーザレベルスレッドとして実装されています。
```

#### プリエンプティブ(Thread) vs 協調的(Fiber)

コンピュータにおいて、マルチタスクのスケジューリング方式には大きくわけて "Preemptive" と "Cooperative" の二種類があります。

##### Preemptive方式 

Preemptive 方式ではタスク自身が実行スケジュールをコントロールせず、OSあるいはVMに処理の切り替えを任せるものです。
そもそも "preemption" とはとは「横取り」を意味します。Preemptive なマルチタスクとは、途中で処理が別タスクに横取りされる可能性のある方法と呼ぶこともできます。

##### Cooperative方式

それに対して "Cooperative" 「協調的」なマルチタスクとは、タスク自身が「終わりましたので次どうぞ」と処理を親に返す方式です。ノンプリエンプティブとも呼ばれます。
Ruby においてこの協調的なタスクを扱うクラスが Fiber なのです。

スレッドは生成されてすぐに処理が開始されますが、Fiber は処理の開始タイミングをコントロールできます。
そのほか「処理を途中まで実行しておいてストップし、また好きなタイミングで続きを実行する」ことも可能です。

## Fiber

### Description

コンピュータサイエンスでは、ファイバーは特に軽量な実行スレッドです。

スレッドと同様に、 Fiber はアドレス空間を共有します。ただし、スレッドはプリエンプティブマルチタスクを仕様するのに対し、
ファイバは協調的マルチタスクを使用します。スレッドはビジー状態のスレッドを横取りして別のスレッドを再開するために、カーネルのスレッドスケジューラに依存することがよくあります。
実行中に、Fiber は別の Fiber を実行するようになります。

### Advantages and disadvantages(長所と短所）

Fiber はマルチタスクで協調して動作するので、スレッドの安全性はプリエンプティブにスケジュールされたスレッドよりも問題は少なく、
また、スピンコードやアトミック操作を含む同期コンストラクトは暗黙的に同期されるので不要です。ただし、多くのライブラリは、ノンブロッキングI/Oを実行する方法として
Fiber を暗黙的に生成します。

欠点は、プリエンプティブスレッドも使用しないと、 Fiber がマルチプロセッサマシンをを利用できないことです。ただし CPU コア以外にプリエンプティブスレッドを使用しない、
M:Nスレッドモデルは純粋な Fiber または純粋なプリエンプティブスレッドのいずれよりも効率的です。

## M:N(hybrid threading)

M:Nは、M個のアプリケーションスレッドをN個のカーネルエンティティまたは、「仮想プロセッサ」にマッピングします。

これは、カーネルレベル("1:1")ユーザーレベル("N:1")のスレッド化の妥協点です。一般的に、"M:N"スレッド化システムは、
カーネルまたはユーザー空間コードのどちらにも変更が必要であるため、カーネルスレッドよりも実装が複雑です。

"M:N"の実装では、スレッドライブラリは、利用可能かつスケジュール可能なエンティティでユーザスレッドをスケジュールする責任があります。
これにより、システムコールが回避されるため、スレッドのコンテキスト切り替えが非常に高速になります。
しかしながら、これは、ユーザーランドスケジューラーとカーネルスケジューラーとの間の広範は（かつ高価）調整なしに、複雑さおよび優先順位の
逆転の可能性並びに次善のスケジューリングを増大させる。
