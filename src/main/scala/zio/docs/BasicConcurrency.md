# Basic Concurrency

## First

ZIO は fibers を使用し、並行性を低レベルでサポートしています。
Fibers は非常に協力ですが低レベルです。生産性を向上させるために ZIO は Fibers で構築された高レベルの操作を提供します。

## Fibers

ZIO の同時実行性は、ZIO の同時実行性は、
ZIOランタイムによって実装される軽量の「green thread」である Fibers 上に構築されています。

オペレーティングシステムのスレッドとは異なり、ファイバはほとんどメモリを消費せず、拡張可能で縮小可能なスタックを持ち、
リソースのブロックを無駄にしません。また、アクティブで到達不可能な場合はガベージコレクションされます。

ZIOのすべての作用は、いくつかの Fiber によって実行されます。 Fiber を作成しなかった場合は、
使用している操作（操作が並行または並列の場合）、またはランタイムシステムによって Fiber が作られます。

たとえあなたが「single-threaded」なコードを書くだけで、並列または同時操作無しだったとしても少なくとも
1つの Fiber があるでしょう。あなたの処理を実行する「main」の Fiber です。

## The Fiber Data Type

ZIO の `Fiber[E, A]` は２つのパラメータを持ちます。
→ BI Functor と呼ばれるやつか。

+ `E` `Failure Type`. これは Fiber によって実行されている効果が失敗した時の値の型です。
+ `A` `Success Type`. これは Fiber によって実行されている効果が成功した時の値の型です。

Fiber には `R` の型パラメーターはありません。なぜなら、それらは既に実行されている効果のモデルを表現しているため、
必要な環境は既に提供されているからです。

## Forking Effects

fiber を作成するもっとも簡単な方法は効果を実行し、それそ fork することです。
概念的には、効果を fork するとすぐに新しい fiber で効果が実行され新しい fiber が得られます。

## Joining Effects

fiber に関するメソッドの一つに `join` があります。
これにより、別の fiber が結合された fiber の結果を取得できるようになります。
これはそれが失敗であろうと成功であろうと、fiber の最終結果を待つのとにています。

## Awaiting Fibers

他のメソッドには `await` があります。これは完成した fiber の結果を検査することを可能にします。
これにより、fiber がどのように完了したかの完全な詳細へのアクセスが提供されます。これは `Exit` 型で表現されます。

## Interrupting Fibers

結果が不要になった Fiber は中断される可能性があり、それによって Fiber が即座に終了し、
すべてのリソースが安全に解放され、すべてのファイナライザが実行されます。

`await` のように、 Fiber#interrupt が戻って、Fiber の終了方法を説明する `Exit` を返します。

設計上、割り込みは fiber が終了するまで再開しません。この動作が望ましくない場合は、
割り込み自体をフォークすることができます。

## Composing Fibers

Fiber を構成するにはいくつかの方法があります。

Fiber を構成する方法の1つは、 Fiber#zip または Fiber#zipWith を使用することです。
これらの方法では、2本の Fiber を1本にまとめ両方の結果を生み出します。どちらかが壊れると合成 fiber は壊れます。

もう一つの方法は、`orElse` を使用することです。最初の Fiber が成功すると、
合成された Fiber もその結果で成功します。最初の Fiber が失敗すると、第2の Fiber の結果で完了する。

## Parallelism

ZIO は作用を並行して実行するための多くの操作を提供します。
これらのメソッドはすべて `Par` サフィックスで命名されているので、
コードを並列化する機械を簡単に識別できます。

たとえば、通常の `ZIO#zio` メソッドは2つの作用を順番に一緒に圧縮します。
しかし、 `ZIO#zipPar` メソッドもあります。これは2つの作用を並列に圧縮します。


